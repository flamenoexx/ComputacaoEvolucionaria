# -*- coding: utf-8 -*-
"""Otimizacao.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NI9N_B5ZkdIOSWs6HKFzRHGi6BwCVhTq
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Parâmetros do sistema
m = 0.1
M = 1.0
l = 0.5
b = 0.1
d = 0.05
I = 0.006
g = 9.81
K_F = 1.0

# Dinâmica do pêndulo invertido
def pendulum_dynamics(t, y, u):
    x, x_dot, theta, theta_dot = y
    sin_theta = np.sin(theta)
    cos_theta = np.cos(theta)

    x_ddot = (K_F * u + m * l * theta_dot**2 * sin_theta - b * x_dot) / (m + M)
    theta_ddot = (m * g * sin_theta - m * l * cos_theta * x_ddot - d * theta_dot) / (I + m * l**2)

    return [x_dot, x_ddot, theta_dot, theta_ddot]

# Controlador PID
class PIDController:
    def __init__(self, kp, ki, kd):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.integral = 0
        self.prev_error = 0

    def control(self, error, dt):
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt
        self.prev_error = error
        return self.kp * error + self.ki * self.integral + self.kd * derivative

# Simulação
def simulate_pendulum(kp, ki, kd, time_span, initial_conditions, num_points=500):
    t_values = np.linspace(time_span[0], time_span[1], num_points)
    dt = t_values[1] - t_values[0]
    y_values = np.zeros((num_points, len(initial_conditions)))
    y_values[0] = initial_conditions

    pid = PIDController(kp, ki, kd)

    for i in range(1, num_points):
        t = t_values[i-1]
        y = y_values[i-1]
        error = -y[2]  # Controlar o ângulo theta para zero
        u = pid.control(error, dt)
        sol = solve_ivp(pendulum_dynamics, [t, t + dt], y, args=(u,), t_eval=[t + dt])
        y_values[i] = sol.y.flatten()

    return t_values, y_values

# Função de custo (IAE)
def cost_function(params):
    kp, ki, kd = params
    time_span = [0, 5]  # Reduzir o tempo de simulação para melhorar o desempenho
    initial_conditions = [0, 0, np.pi / 4, 0]  # Ângulo inicial de 45 graus
    t_values, y_values = simulate_pendulum(kp, ki, kd, time_span, initial_conditions)
    theta_values = y_values[:, 2]
    iae = np.sum(np.abs(theta_values))  # Integral do Erro Absoluto
    return iae

# Algoritmo PSO
class Particle:
    def __init__(self, bounds):
        self.position = np.array([np.random.uniform(low, high) for low, high in bounds])
        self.velocity = np.zeros_like(self.position)
        self.best_position = self.position.copy()
        self.best_value = float('inf')

def pso_optimize(cost_function, bounds, num_particles=20, max_iter=50):
    particles = [Particle(bounds) for _ in range(num_particles)]
    global_best_position = np.zeros_like(particles[0].position)
    global_best_value = float('inf')

    w = 0.5  # Inércia
    c1 = 1.5  # Coeficiente de aceleração cognitiva
    c2 = 2.0  # Coeficiente de aceleração social

    for i in range(max_iter):
        for particle in particles:
            # Avaliar o custo da posição atual
            current_value = cost_function(particle.position)
            if current_value < particle.best_value:
                particle.best_position = particle.position.copy()
                particle.best_value = current_value
            if current_value < global_best_value:
                global_best_position = particle.position.copy()
                global_best_value = current_value

        for particle in particles:
            r1 = np.random.random(len(bounds))
            r2 = np.random.random(len(bounds))
            particle.velocity = (w * particle.velocity +
                                 c1 * r1 * (particle.best_position - particle.position) +
                                 c2 * r2 * (global_best_position - particle.position))
            particle.position += particle.velocity

    return global_best_position

# Definir limites dos parâmetros [kp, ki, kd]
bounds = [(0, 300), (0, 600), (0, 50)]

# Otimização com PSO
best_params = pso_optimize(cost_function, bounds)
kp_opt, ki_opt, kd_opt = best_params

print(f"Parâmetros Otimizados: Kp={kp_opt}, Ki={ki_opt}, Kd={kd_opt}")

# Simulação com os parâmetros otimizados
time_span = [0, 5]  # Reduzir o tempo de simulação para melhorar o desempenho
initial_conditions = [0, 0, np.pi / 4, 0]
t_values, y_values = simulate_pendulum(kp_opt, ki_opt, kd_opt, time_span, initial_conditions)

# Plotagem dos resultados
plt.figure(figsize=(10, 8))
plt.subplot(3, 1, 1)
plt.plot(t_values, y_values[:, 0], label='Posição do Carrinho')
plt.ylabel('Posição (cm)')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(t_values, y_values[:, 2], label='Ângulo do Pêndulo')
plt.ylabel('Ângulo (rad)')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(t_values, y_values[:, 1], label='Velocidade do Carrinho')
plt.plot(t_values, y_values[:, 3], label='Velocidade Angular do Pêndulo')
plt.ylabel('Velocidade (m/s e rad/s)')
plt.xlabel('Tempo (s)')
plt.legend()

plt.tight_layout()
plt.show()